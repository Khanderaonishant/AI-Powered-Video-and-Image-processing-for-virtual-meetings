<!DOCTYPE html>
<html>
<head>
    <title>AI Proctoring System</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        .video-container {
            flex: 1;
        }
        .results-container {
            flex: 1;
        }
        #video {
            width: 100%;
            height: 480px;
            background-color: #666;
            border-radius: 8px;
        }
        #canvas {
            display: none;
        }
        .status-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .status-item {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
        }
        .normal {
            background-color: #e8f5e9;
            color: #2e7d32;
        }
        .alert {
            background-color: #ffebee;
            color: #c62828;
            font-weight: bold;
        }
        #logs {
            height: 300px;
            overflow-y: auto;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .log-entry {
            margin-bottom: 10px;
            padding: 10px;
            border-left: 4px solid #ddd;
        }
        .log-alert {
            border-left-color: #c62828;
            background-color: #ffebee;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 15px;
            background-color: #1976d2;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #1565c0;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .alert-count {
            background-color: #c62828;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 0.8em;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <h1>AI Proctoring System</h1>
    
    <div class="controls">
        <label for="cameraSelect">Camera:</label>
        <select id="cameraSelect"></select>
        <button id="startBtn">Start Proctoring</button>
        <button id="stopBtn">Stop Proctoring</button>
        <button id="clearLogsBtn">Clear Logs</button>
    </div>
    
    <div class="container">
        <div class="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="results-container">
            <div class="status-panel">
                <h2>Current Status <span id="alertCount" class="alert-count" style="display: none;">0</span></h2>
                <div id="statusItems">
                    <div class="status-item" id="faceStatus">
                        <span>Face Recognition:</span>
                        <span>Not detected</span>
                    </div>
                    <div class="status-item" id="headPoseStatus">
                        <span>Head Position:</span>
                        <span>Not detected</span>
                    </div>
                    <div class="status-item" id="eyeStatus">
                        <span>Eye Tracking:</span>
                        <span>Not detected</span>
                    </div>
                    <div class="status-item" id="mouthStatus">
                        <span>Mouth Movement:</span>
                        <span>Not detected</span>
                    </div>
                    <div class="status-item" id="spoofStatus">
                        <span>Face Spoofing:</span>
                        <span>Not detected</span>
                    </div>
                    <div class="status-item" id="objectsStatus">
                        <span>Banned Objects:</span>
                        <span>None</span>
                    </div>
                </div>
            </div>
            
            <h2>Activity Log</h2>
            <div id="logs"></div>
        </div>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const logs = document.getElementById('logs');
        const cameraSelect = document.getElementById('cameraSelect');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        const alertCount = document.getElementById('alertCount');
        
        const statusElements = {
            face: document.getElementById('faceStatus'),
            headPose: document.getElementById('headPoseStatus'),
            eye: document.getElementById('eyeStatus'),
            mouth: document.getElementById('mouthStatus'),
            spoof: document.getElementById('spoofStatus'),
            objects: document.getElementById('objectsStatus')
        };
        
        let stream = null;
        let processingInterval = null;
        let alertCounter = 0;

        async function getCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(device => device.kind === 'videoinput');
                cameraSelect.innerHTML = '';
                videoDevices.forEach((device, idx) => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.text = device.label || `Camera ${idx + 1}`;
                    cameraSelect.appendChild(option);
                });
                
                if (videoDevices.length > 0) {
                    await startCamera(videoDevices[0].deviceId);
                }
            } catch (err) {
                addLog(`Error accessing cameras: ${err.message}`, true);
            }
        }

        async function startCamera(deviceId) {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        deviceId: { exact: deviceId },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                video.srcObject = stream;
                addLog('Camera started successfully');
            } catch (err) {
                addLog(`Error starting camera: ${err.message}`, true);
            }
        }

        async function captureFrame() {
            if (video.readyState !== 4) return;
            
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            const imageData = canvas.toDataURL('image/jpeg').split(',')[1];

            try {
                const response = await fetch('http://localhost:5000/api/capture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ image: imageData })
                });
                
                const result = await response.json();
                updateStatusPanel(result);
                
                if (result.alerts && result.alerts.length > 0) {
                    result.alerts.forEach(alert => addLog(alert, true));
                    alertCounter += result.alerts.length;
                    alertCount.textContent = alertCounter;
                    alertCount.style.display = 'inline-block';
                } else {
                    addLog('Normal activity detected');
                }
            } catch (err) {
                addLog(`Error processing frame: ${err.message}`, true);
            }
        }

        function updateStatusPanel(data) {
            // Face Recognition
            updateStatusElement(
                statusElements.face,
                data.face_recognition,
                data.face_recognition === "No face detected" || data.face_recognition === "Unknown"
            );
            
            // Head Pose
            const headPoseText = data.head_pose.status === "Normal" 
                ? "Normal" 
                : `Suspicious (Pitch: ${data.head_pose.pitch.toFixed(1)}°, Yaw: ${data.head_pose.yaw.toFixed(1)}°)`;
            updateStatusElement(
                statusElements.headPose,
                headPoseText,
                data.head_pose.status !== "Normal"
            );
            
            // Eye Tracking
            updateStatusElement(
                statusElements.eye,
                data.eye_tracking,
                data.eye_tracking !== "Looking at screen"
            );
            
            // Mouth Movement
            const mouthText = data.mouth_open ? "Open" : "Closed";
            updateStatusElement(
                statusElements.mouth,
                mouthText,
                data.mouth_open
            );
            
            // Face Spoofing
            const spoofText = data.face_spoofing ? "Possible spoof" : "Genuine";
            updateStatusElement(
                statusElements.spoof,
                spoofText,
                data.face_spoofing
            );
            
            // Banned Objects
            const objectsText = data.banned_objects.length > 0 
                ? data.banned_objects.join(', ') 
                : "None";
            updateStatusElement(
                statusElements.objects,
                objectsText,
                data.banned_objects.length > 0
            );
        }

        function updateStatusElement(element, text, isAlert) {
            const valueSpan = element.querySelector('span:last-child');
            valueSpan.textContent = text;
            
            element.className = 'status-item';
            if (isAlert) {
                element.classList.add('alert');
            } else {
                element.classList.add('normal');
            }
        }

        function addLog(message, isAlert = false) {
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry' + (isAlert ? ' log-alert' : '');
            logEntry.innerHTML = `<strong>[${timeString}]</strong> ${message}`;
            
            logs.appendChild(logEntry);
            logs.scrollTop = logs.scrollHeight;
        }

        function startProctoring() {
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = setInterval(captureFrame, 2000); // Process every 2 seconds
            addLog('Proctoring started');
            startBtn.disabled = true;
            stopBtn.disabled = false;
        }

        function stopProctoring() {
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = null;
            addLog('Proctoring stopped');
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }

        async function clearLogs() {
            try {
                await fetch('http://localhost:5000/api/clear_logs', {
                    method: 'POST'
                });
                logs.innerHTML = '';
                alertCounter = 0;
                alertCount.style.display = 'none';
                addLog('Logs cleared');
            } catch (err) {
                addLog(`Error clearing logs: ${err.message}`, true);
            }
        }

        // Event Listeners
        startBtn.addEventListener('click', startProctoring);
        stopBtn.addEventListener('click', stopProctoring);
        clearLogsBtn.addEventListener('click', clearLogs);
        stopBtn.disabled = true;
        
        cameraSelect.addEventListener('change', async () => {
            await startCamera(cameraSelect.value);
        });

        // Initialize
        window.onload = getCameras;
    </script>
</body>
</html>